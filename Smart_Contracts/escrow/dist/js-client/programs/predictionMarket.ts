/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  type ParsedClaimWinningsInstruction,
  type ParsedCloseMarketInstruction,
  type ParsedCreateMarketInstruction,
  type ParsedPlaceBetInstruction,
  type ParsedResolveMarketInstruction,
} from '../instructions';

export const PREDICTION_MARKET_PROGRAM_ADDRESS =
  '7yMnrzoEQZ6DmgNLH7PRoHduGRffPdMq7H1drrMZV83H' as Address<'7yMnrzoEQZ6DmgNLH7PRoHduGRffPdMq7H1drrMZV83H'>;

export enum PredictionMarketAccount {
  Bet,
  Market,
}

export function identifyPredictionMarketAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): PredictionMarketAccount {
  const data = 'data' in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([147, 23, 35, 59, 15, 75, 155, 32])
      ),
      0
    )
  ) {
    return PredictionMarketAccount.Bet;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([219, 190, 213, 55, 0, 227, 198, 154])
      ),
      0
    )
  ) {
    return PredictionMarketAccount.Market;
  }
  throw new Error(
    'The provided account could not be identified as a predictionMarket account.'
  );
}

export enum PredictionMarketInstruction {
  ClaimWinnings,
  CloseMarket,
  CreateMarket,
  PlaceBet,
  ResolveMarket,
}

export function identifyPredictionMarketInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): PredictionMarketInstruction {
  const data = 'data' in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([161, 215, 24, 59, 14, 236, 242, 221])
      ),
      0
    )
  ) {
    return PredictionMarketInstruction.ClaimWinnings;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([88, 154, 248, 186, 48, 14, 123, 244])
      ),
      0
    )
  ) {
    return PredictionMarketInstruction.CloseMarket;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([103, 226, 97, 235, 200, 188, 251, 254])
      ),
      0
    )
  ) {
    return PredictionMarketInstruction.CreateMarket;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([222, 62, 67, 220, 63, 166, 126, 33])
      ),
      0
    )
  ) {
    return PredictionMarketInstruction.PlaceBet;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([155, 23, 80, 173, 46, 74, 23, 239])
      ),
      0
    )
  ) {
    return PredictionMarketInstruction.ResolveMarket;
  }
  throw new Error(
    'The provided instruction could not be identified as a predictionMarket instruction.'
  );
}

export type ParsedPredictionMarketInstruction<
  TProgram extends string = '7yMnrzoEQZ6DmgNLH7PRoHduGRffPdMq7H1drrMZV83H',
> =
  | ({
      instructionType: PredictionMarketInstruction.ClaimWinnings;
    } & ParsedClaimWinningsInstruction<TProgram>)
  | ({
      instructionType: PredictionMarketInstruction.CloseMarket;
    } & ParsedCloseMarketInstruction<TProgram>)
  | ({
      instructionType: PredictionMarketInstruction.CreateMarket;
    } & ParsedCreateMarketInstruction<TProgram>)
  | ({
      instructionType: PredictionMarketInstruction.PlaceBet;
    } & ParsedPlaceBetInstruction<TProgram>)
  | ({
      instructionType: PredictionMarketInstruction.ResolveMarket;
    } & ParsedResolveMarketInstruction<TProgram>);
