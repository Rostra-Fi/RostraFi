{"version":3,"sources":["../src/lib/connect.ts","../src/lib/url.ts","../src/lib/keypair.ts","../src/lib/constants.ts","../src/lib/crypto.ts","../src/lib/clusters.ts","../src/lib/transactions.ts","../src/lib/smart-transactions.ts","../node_modules/@solana/promises/src/race.ts","../node_modules/@solana/promises/src/abortable.ts","../src/lib/logs.ts","../src/lib/wallets.ts","../src/lib/tokens.ts","../src/lib/explorer.ts","../src/lib/sol.ts","../src/lib/pdas.ts","../src/lib/accounts.ts"],"sourcesContent":["import {\n  createDefaultRpcTransport,\n  createSolanaRpcFromTransport,\n  createSolanaRpcSubscriptions,\n  sendAndConfirmTransactionFactory,\n  KeyPairSigner,\n  Address,\n  RpcTransport,\n} from \"@solana/kit\";\nimport { createRecentSignatureConfirmationPromiseFactory } from \"@solana/transaction-confirmation\";\n\nimport { checkIsValidURL, encodeURL } from \"./url\";\nimport { loadWalletFromEnvironment, loadWalletFromFile } from \"./keypair\";\nimport { KNOWN_CLUSTER_NAMES, CLUSTERS, KNOWN_CLUSTER_NAMES_STRING } from \"./clusters\";\n\nimport { sendTransactionFromInstructionsFactory } from \"./transactions\";\nimport { createWalletFactory, createWalletsFactory } from \"./wallets\";\nimport {\n  getMintFactory,\n  getTokenAccountAddress,\n  createTokenMintFactory,\n  mintTokensFactory,\n  transferLamportsFactory,\n  transferTokensFactory,\n  getTokenAccountBalanceFactory,\n  checkTokenAccountIsClosedFactory,\n} from \"./tokens\";\nimport { getLogsFactory } from \"./logs\";\nimport { getExplorerLinkFactory } from \"./explorer\";\nimport { airdropIfRequiredFactory, getLamportBalanceFactory } from \"./sol\";\nimport { getPDAAndBump } from \"./pdas\";\nimport { getAccountsFactoryFactory } from \"./accounts\";\n\n/**\n * Creates a connection to a Solana cluster with all helper functions pre-configured.\n * @param {string} [clusterNameOrURL=\"localnet\"] - Either a known cluster name or an HTTP URL\n *                 Known names: \"mainnet-beta\"/\"mainnet\", \"testnet\", \"devnet\", \"localnet\",\n *                 \"helius-mainnet\", \"helius-testnet\", \"helius-devnet\"\n * @param {string | null} [clusterWebSocketURL=null] - WebSocket URL for subscriptions. Required if using custom HTTP URL\n * @returns {Connection} Connection object with all helper functions configured\n * @throws {Error} If using Helius cluster without HELIUS_API_KEY environment variable set\n * @throws {Error} If using custom HTTP URL without WebSocket URL\n * @throws {Error} If cluster name is invalid\n */\nexport const connect = (\n  clusterNameOrURL: string = \"localnet\",\n  clusterWebSocketURL: string | null = null,\n): Connection => {\n  let httpURL: string | null = null;\n  let webSocketURL: string | null = null;\n  let supportsGetPriorityFeeEstimate: boolean = false;\n  let needsPriorityFees: boolean = false;\n  let enableClientSideRetries: boolean = false;\n  // Postel's law: be liberal in what you accept - so include 'mainnet' as well as 'mainnet-beta'\n  if (clusterNameOrURL === \"mainnet\") {\n    clusterNameOrURL = \"mainnet-beta\";\n  }\n\n  if (KNOWN_CLUSTER_NAMES.includes(clusterNameOrURL)) {\n    const clusterDetails = CLUSTERS[clusterNameOrURL];\n\n    if (clusterDetails.features.supportsGetPriorityFeeEstimate) {\n      supportsGetPriorityFeeEstimate = true;\n    }\n\n    if (clusterDetails.features.needsPriorityFees) {\n      needsPriorityFees = true;\n    }\n\n    enableClientSideRetries = clusterDetails.features.enableClientSideRetries;\n\n    if (clusterDetails.requiredParamEnvironmentVariable) {\n      const requiredParamEnvironmentVariable = process.env[clusterDetails.requiredParamEnvironmentVariable];\n      if (!requiredParamEnvironmentVariable) {\n        throw new Error(`Environment variable ${clusterDetails.requiredParamEnvironmentVariable} is not set.`);\n      }\n      // Add the URL param 'api-key' with the value of the environment variable\n      // using a URLSearchParams object\n      const queryParamsString = new URLSearchParams({\n        \"api-key\": requiredParamEnvironmentVariable,\n      });\n      httpURL = `${clusterDetails.httpURL}?${queryParamsString}`;\n      webSocketURL = `${clusterDetails.webSocketURL}?${queryParamsString}`;\n    } else {\n      httpURL = clusterDetails.httpURL;\n      webSocketURL = clusterDetails.webSocketURL;\n    }\n  } else {\n    if (!clusterWebSocketURL) {\n      throw new Error(\n        `Missing clusterWebSocketURL. Either provide a valid cluster name (${KNOWN_CLUSTER_NAMES_STRING}) or two valid URLs.`,\n      );\n    }\n    if (checkIsValidURL(clusterNameOrURL) && checkIsValidURL(clusterWebSocketURL)) {\n      httpURL = clusterNameOrURL;\n      webSocketURL = clusterWebSocketURL;\n    } else {\n      throw new Error(\n        `Unsupported cluster name (valid options are ${KNOWN_CLUSTER_NAMES_STRING}) or URL: ${clusterNameOrURL}. `,\n      );\n    }\n  }\n\n  const transport = createDefaultRpcTransport({\n    url: httpURL,\n  });\n\n  // Create an RPC client using that transport.\n  const rpc = createSolanaRpcFromTransport(transport);\n\n  const rpcSubscriptions = createSolanaRpcSubscriptions(webSocketURL);\n  const sendAndConfirmTransaction = sendAndConfirmTransactionFactory({\n    rpc,\n    rpcSubscriptions,\n  });\n\n  // Let's avoid data types like 'Promise' into the function name\n  // we're not using Hungarian notation, this isn't common TS behavior, and it's not necessary to do so\n  const getRecentSignatureConfirmation = createRecentSignatureConfirmationPromiseFactory({\n    rpc,\n    rpcSubscriptions,\n  });\n\n  const airdropIfRequired = airdropIfRequiredFactory(rpc, rpcSubscriptions);\n\n  const createWallet = createWalletFactory(airdropIfRequired);\n\n  const createWallets = createWalletsFactory(createWallet);\n\n  const getLogs = getLogsFactory(rpc);\n\n  const sendTransactionFromInstructions = sendTransactionFromInstructionsFactory(\n    rpc,\n    needsPriorityFees,\n    supportsGetPriorityFeeEstimate,\n    enableClientSideRetries,\n    sendAndConfirmTransaction,\n  );\n\n  const transferLamports = transferLamportsFactory(sendTransactionFromInstructions);\n\n  const createTokenMint = createTokenMintFactory(rpc, sendTransactionFromInstructions);\n\n  const getMint = getMintFactory(rpc);\n\n  const transferTokens = transferTokensFactory(getMint, sendTransactionFromInstructions);\n\n  const mintTokens = mintTokensFactory(sendTransactionFromInstructions);\n\n  const getTokenAccountBalance = getTokenAccountBalanceFactory(rpc);\n\n  const checkTokenAccountIsClosed = checkTokenAccountIsClosedFactory(getTokenAccountBalance);\n\n  const getAccountsFactory = getAccountsFactoryFactory(rpc);\n\n  return {\n    rpc,\n    rpcSubscriptions,\n    sendAndConfirmTransaction,\n    sendTransactionFromInstructions,\n    getLamportBalance: getLamportBalanceFactory(rpc),\n    getExplorerLink: getExplorerLinkFactory(clusterNameOrURL),\n    airdropIfRequired,\n    createWallet,\n    createWallets,\n    getLogs,\n    getRecentSignatureConfirmation,\n    transferLamports,\n    transferTokens,\n    createTokenMint,\n    mintTokens,\n    getTokenAccountAddress,\n    loadWalletFromFile,\n    loadWalletFromEnvironment,\n    getMint,\n    getTokenAccountBalance,\n    getPDAAndBump,\n    checkTokenAccountIsClosed,\n    getAccountsFactory,\n  };\n};\n\nexport interface Connection {\n  /**\n   * The core RPC client for making direct Solana API calls. Use this when you need\n   * access to raw Solana JSON RPC methods not covered by helper functions.\n   */\n  rpc: ReturnType<typeof createSolanaRpcFromTransport<RpcTransport>>;\n\n  /**\n   * The WebSocket client for real-time Solana event subscriptions like new blocks,\n   * program logs, account changes etc.\n   */\n  rpcSubscriptions: ReturnType<typeof createSolanaRpcSubscriptions>;\n\n  /**\n   * Submits a transaction and waits for it to be confirmed on the network.\n   * @param {VersionedTransaction} transaction - The complete signed transaction to submit\n   * @param {Object} [options] - Optional configuration\n   * @param {Commitment} [options.commitment] - Confirmation level to wait for:\n   *                                           'processed' = processed by current node,\n   *                                           'confirmed' = confirmed by supermajority of the cluster,\n   *                                           'finalized' = confirmed by supermajority and unlikely to revert\n   * @param {boolean} [options.skipPreflight] - Skip pre-flight transaction checks to reduce latency\n   * @returns {Promise<void>}\n   */\n  sendAndConfirmTransaction: ReturnType<typeof sendAndConfirmTransactionFactory>;\n\n  /**\n   * Builds, signs and sends a transaction containing multiple instructions.\n   * @param {Object} params - Transaction parameters\n   * @param {KeyPairSigner} params.feePayer - Account that will pay the transaction fees\n   * @param {Array<IInstruction>} params.instructions - List of instructions to execute in sequence\n   * @param {Commitment} [params.commitment=\"confirmed\"] - Confirmation level to wait for:\n   *                                                      'processed' = processed by current node,\n   *                                                      'confirmed' = confirmed by supermajority of the cluster,\n   *                                                      'finalized' = confirmed by supermajority and unlikely to revert\n   * @param {boolean} [params.skipPreflight=true] - Skip pre-flight transaction checks to reduce latency\n   * @param {number} [params.maximumClientSideRetries=0] - Number of times to retry if the transaction fails\n   * @param {AbortSignal | null} [params.abortSignal=null] - Signal to cancel the transaction\n   * @returns {Promise<string>} The transaction signature\n   */\n  sendTransactionFromInstructions: ReturnType<typeof sendTransactionFromInstructionsFactory>;\n\n  /**\n   * Gets an account's SOL balance in lamports (1 SOL = 1,000,000,000 lamports).\n   * @param {string} address - The account address to check\n   * @param {Commitment} commitment - Confirmation level of data:\n   *                                 'processed' = maybe outdated but fast,\n   *                                 'confirmed' = confirmed by supermajority,\n   *                                 'finalized' = definitely permanent but slower\n   * @returns {Promise<Lamports>} The balance in lamports\n   */\n  getLamportBalance: ReturnType<typeof getLamportBalanceFactory>;\n\n  /**\n   * Creates a URL to view any Solana entity on Solana Explorer.\n   * Automatically configures the URL for the current network/cluster.\n   * @param {(\"transaction\" | \"tx\" | \"address\" | \"block\")} linkType - What type of entity to view\n   * @param {string} id - Identifier (address, signature, or block number)\n   * @returns {string} A properly configured Solana Explorer URL\n   */\n  getExplorerLink: ReturnType<typeof getExplorerLinkFactory>;\n\n  /**\n   * Checks if a transaction has been confirmed on the network.\n   * Useful for verifying that time-sensitive transactions have succeeded.\n   * @param {string} signature - The unique transaction signature to verify\n   * @returns {Promise<boolean>} True if the transaction is confirmed\n   */\n  getRecentSignatureConfirmation: ReturnType<typeof createRecentSignatureConfirmationPromiseFactory>;\n\n  /**\n   * Checks if a token account is closed or doesn't exist.\n   * A token account can be specified directly or derived from a wallet and mint address.\n   * @param {Object} params - Parameters for checking token account\n   * @param {Address} [params.tokenAccount] - Direct token account address to check\n   * @param {Address} [params.wallet] - Wallet address (required if tokenAccount not provided)\n   * @param {Address} [params.mint] - Token mint address (required if tokenAccount not provided)\n   * @param {boolean} [params.useTokenExtensions=false] - Use Token Extensions program instead of classic Token program\n   * @returns {Promise<boolean>} True if the token account is closed or doesn't exist, false if it exists and is open\n   * @throws {Error} If neither tokenAccount nor both wallet and mint are provided\n   * @throws {Error} If there's an error checking the account that isn't related to the account not existing\n   */\n  checkTokenAccountIsClosed: ReturnType<typeof checkTokenAccountIsClosedFactory>;\n\n  /**\n   * Requests free test SOL from a faucet if an account's balance is too low.\n   * Only works on test networks (devnet/testnet).\n   * @param {Address} address - The account that needs SOL\n   * @param {Lamports} airdropAmount - How much SOL to request (in lamports)\n   * @param {Lamports} minimumBalance - Only request SOL if balance is below this amount\n   * @param {Commitment} commitment - Confirmation level to wait for:\n   *                                 'processed' = processed by current node,\n   *                                 'confirmed' = confirmed by supermajority of the cluster,\n   *                                 'finalized' = confirmed by supermajority and unlikely to revert\n   * @returns {Promise<string | null>} Transaction signature if SOL was airdropped, null if no airdrop was needed\n   */\n  airdropIfRequired: ReturnType<typeof airdropIfRequiredFactory>;\n\n  /**\n   * Creates a new Solana wallet with optional vanity address and automatic funding.\n   * @param {Object} [options={}] - Configuration options\n   * @param {string | null} [options.prefix] - Generate address starting with these characters\n   * @param {string | null} [options.suffix] - Generate address ending with these characters\n   * @param {string | null} [options.envFileName] - Save private key to this .env file\n   * @param {string} [options.envVariableName] - Environment variable name to store the key\n   * @param {Lamports | null} [options.airdropAmount] - Amount of test SOL to request from faucet\n   * @returns {Promise<KeyPairSigner>} The new wallet, ready to use\n   */\n  createWallet: ReturnType<typeof createWalletFactory>;\n\n  /**\n   * Creates multiple Solana wallets in parallel with identical configuration.\n   * @param {number} amount - How many wallets to create\n   * @param {Object} options - Same configuration options as createWallet\n   * @returns {Promise<Array<KeyPairSigner>>} Array of new wallets\n   */\n  createWallets: ReturnType<typeof createWalletsFactory>;\n\n  /**\n   * Retrieves the program output messages from a transaction.\n   * Useful for debugging failed transactions or understanding program behavior.\n   * @param {string} signature - Transaction signature to analyze\n   * @returns {Promise<readonly Array<string>>} Program log messages in order of execution\n   */\n  getLogs: ReturnType<typeof getLogsFactory>;\n\n  /**\n   * Transfers SOL from one account to another.\n   * @param {Object} params - Transfer details\n   * @param {KeyPairSigner} params.source - Account sending the SOL (must sign)\n   * @param {Address} params.destination - Account receiving the SOL\n   * @param {Lamports} params.amount - Amount of SOL to send (in lamports)\n   * @param {boolean} [params.skipPreflight=true] - Skip pre-flight checks to reduce latency\n   * @param {number} [params.maximumClientSideRetries=0] - Number of retry attempts if transfer fails\n   * @param {AbortSignal | null} [params.abortSignal=null] - Signal to cancel the transfer\n   * @returns {Promise<string>} Transaction signature\n   */\n  transferLamports: ReturnType<typeof transferLamportsFactory>;\n\n  /**\n   * Creates a new SPL token with metadata and minting controls.\n   * @param {Object} params - Token configuration\n   * @param {KeyPairSigner} params.mintAuthority - Account that will have permission to mint tokens\n   * @param {number} params.decimals - Number of decimal places (e.g. 9 decimals means 1 token = 1,000,000,000 base units)\n   * @param {string} params.name - Display name of the token\n   * @param {string} params.symbol - Short ticker symbol (e.g. \"USDC\")\n   * @param {string} params.uri - URL to token metadata (image, description etc.)\n   * @param {Record<string, string> | Map<string, string>} [params.additionalMetadata={}] - Extra metadata key-value pairs\n   * @returns {Promise<Address>} Address of the new token mint\n   */\n  createTokenMint: (params: {\n    mintAuthority: KeyPairSigner;\n    decimals: number;\n    name: string;\n    symbol: string;\n    uri: string;\n    additionalMetadata?: Record<string, string> | Map<string, string>;\n  }) => Promise<Address>;\n\n  /**\n   * Creates new tokens from a token mint.\n   * @param {Address} mintAddress - The token mint to create tokens from\n   * @param {KeyPairSigner} mintAuthority - Account authorized to mint new tokens (must sign)\n   * @param {bigint} amount - Number of base units to mint (adjusted for decimals)\n   * @param {Address} destination - Account to receive the new tokens\n   * @returns {Promise<string>} Transaction signature\n   */\n  mintTokens: (\n    mintAddress: Address,\n    mintAuthority: KeyPairSigner,\n    amount: bigint,\n    destination: Address,\n  ) => Promise<string>;\n\n  /**\n   * Transfers SPL tokens between accounts.\n   * @param {Object} params - Transfer details\n   * @param {KeyPairSigner} params.sender - Account sending the tokens (must sign)\n   * @param {Address} params.destination - Account receiving the tokens\n   * @param {Address} params.mintAddress - The type of token to transfer\n   * @param {bigint} params.amount - Number of base units to transfer (adjusted for decimals)\n   * @param {number} [params.maximumClientSideRetries=0] - Number of retry attempts if transfer fails\n   * @param {AbortSignal | null} [params.abortSignal=null] - Signal to cancel the transfer\n   * @returns {Promise<string>} Transaction signature\n   */\n  transferTokens: ReturnType<typeof transferTokensFactory>;\n\n  /**\n   * Retrieves information about a token mint including supply and decimals.\n   * @param {Address} mintAddress - Address of the token mint to query\n   * @param {Commitment} [commitment=\"confirmed\"] - Confirmation level of data:\n   *                                               'processed' = maybe outdated but fast,\n   *                                               'confirmed' = confirmed by supermajority,\n   *                                               'finalized' = definitely permanent but slower\n   * @returns {Promise<Mint | null>} Token information if found, null if not\n   */\n  getMint: ReturnType<typeof getMintFactory>;\n\n  /**\n   * Gets the token balance for a specific account. You can either provide a token account address directly, or provide a wallet address and a mint address to derive the token account address.\n   * @param {Object} params - Parameters for getting token balance\n   * @param {Address} [params.tokenAccount] - Direct token account address to check balance for\n   * @param {Address} [params.wallet] - Wallet address (required if tokenAccount not provided)\n   * @param {Address} [params.mint] - Token mint address (required if tokenAccount not provided)\n   * @param {boolean} [params.useTokenExtensions=false] - Use Token Extensions program instead of classic Token program\n   * @returns {Promise<{amount: BigInt, decimals: number, uiAmount: number | null, uiAmountString: string}>} Balance information including amount and decimals\n   * @throws {Error} If neither tokenAccount nor both wallet and mint are provided\n   */\n  getTokenAccountBalance: (params: {\n    tokenAccount?: Address;\n    wallet?: Address;\n    mint?: Address;\n    useTokenExtensions?: boolean;\n  }) => Promise<{\n    amount: BigInt;\n    decimals: number;\n    uiAmount: number | null;\n    uiAmountString: string;\n  }>;\n\n  /**\n   * Gets the address where a wallet's tokens are stored.\n   * Each wallet has a unique storage address for each type of token.\n   * @param {Address} wallet - The wallet that owns the tokens\n   * @param {Address} mint - The type of token\n   * @param {boolean} [useTokenExtensions=false] - Use Token Extensions program instead of classic Token program\n   * @returns {Promise<Address>} The token account address\n   */\n  getTokenAccountAddress: typeof getTokenAccountAddress;\n\n  /**\n   * Loads a wallet from a file containing a keypair.\n   * Compatible with keypair files generated by 'solana-keygen'.\n   * @param {string} [filepath] - Location of the keypair file (defaults to ~/.config/solana/id.json)\n   * @returns {Promise<KeyPairSigner>} The loaded wallet\n   */\n  loadWalletFromFile: typeof loadWalletFromFile;\n\n  /**\n   * Loads a wallet from an environment variable containing a keypair.\n   * The keypair must be in the same format as 'solana-keygen' (array of numbers).\n   * @param {string} variableName - Name of environment variable storing the keypair\n   * @returns {KeyPairSigner} The loaded wallet\n   */\n  loadWalletFromEnvironment: typeof loadWalletFromEnvironment;\n\n  /**\n   * Derives a Program Derived Address (PDA) and its bump seed.\n   * PDAs are deterministic addresses that programs can sign for.\n   * @param {Address} programAddress - The program that will control this PDA\n   * @param {Array<String | Address | BigInt>} seeds - Values used to derive the PDA\n   * @returns {Promise<{pda: Address, bump: number}>} The derived address and bump seed\n   */\n  getPDAAndBump: typeof getPDAAndBump;\n\n  /**\n   * Creates a factory function for getting program accounts with a specific discriminator.\n   */\n  getAccountsFactory: ReturnType<typeof getAccountsFactoryFactory>;\n}\n","export const getCustomErrorMessage = (\n  possibleProgramErrors: Array<string>,\n  errorMessage: string,\n): string | null => {\n  const customErrorExpression =\n    /.*custom program error: 0x(?<errorNumber>[0-9abcdef]+)/;\n\n  let match = customErrorExpression.exec(errorMessage);\n  const errorNumberFound = match?.groups?.errorNumber;\n  if (!errorNumberFound) {\n    return null;\n  }\n  // errorNumberFound is a base16 string\n  const errorNumber = parseInt(errorNumberFound, 16);\n  return possibleProgramErrors[errorNumber] || null;\n};\n\nexport const encodeURL = (\n  baseUrl: string,\n  searchParams: Record<string, string>,\n) => {\n  // This was a little new to me, but it's the\n  // recommended way to build URLs with query params\n  // (and also means you don't have to do any encoding)\n  // https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams\n  const url = new URL(baseUrl);\n  url.search = new URLSearchParams(searchParams).toString();\n  return url.toString();\n};\n\nexport const checkIsValidURL = (string: string) => {\n  try {\n    new URL(string);\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\n","import { createKeyPairSignerFromBytes, generateKeyPairSigner, KeyPairSigner } from \"@solana/kit\";\nimport { assertKeyGenerationIsAvailable } from \"@solana/assertions\";\nimport { exportRawPrivateKeyBytes, exportRawPublicKeyBytes, getBase58AddressFromPublicKey } from \"./crypto\";\nimport {\n  BASE58_CHARACTER_SET,\n  DEFAULT_FILEPATH,\n  GRIND_COMPLEXITY_THRESHOLD,\n  KEYPAIR_LENGTH,\n  KEYPAIR_PUBLIC_KEY_OFFSET,\n} from \"./constants\";\nconst ALLOW_EXTRACTABLE_PRIVATE_KEY_MESSAGE =\n  \"yes I understand the risk of extractable private keys and will delete this keypair shortly after saving it to a file\";\n\nexport const grindKeyPair = async (options: {\n  prefix?: string | null;\n  suffix?: string | null;\n  silenceGrindProgress?: boolean;\n  isPrivateKeyExtractable?: false | typeof ALLOW_EXTRACTABLE_PRIVATE_KEY_MESSAGE;\n}): Promise<CryptoKeyPair> => {\n  await assertKeyGenerationIsAvailable();\n\n  // Do not allow extractable keyPairs unless the user has explicitly said they understand the risk\n  const allowExtractablePrivateKey = options.isPrivateKeyExtractable === ALLOW_EXTRACTABLE_PRIVATE_KEY_MESSAGE;\n\n  // Ensure the prefix and suffix are within the base58 character set\n  if (options.prefix && !BASE58_CHARACTER_SET.test(options.prefix)) {\n    throw new Error(\"Prefix must contain only base58 characters.\");\n  }\n  if (options.suffix && !BASE58_CHARACTER_SET.test(options.suffix)) {\n    throw new Error(\"Suffix must contain only base58 characters.\");\n  }\n\n  // Add the total length of the prefix and suffix\n  const keypairGrindComplexity = (options.prefix?.length || 0) + (options.suffix?.length || 0);\n  // Throw a warning if keypairGrindComplexity is greater than GRIND_COMPLEXITY_THRESHOLD\n  if (keypairGrindComplexity > GRIND_COMPLEXITY_THRESHOLD) {\n    console.warn(\n      `Generating a keyPair with a prefix and suffix of ${keypairGrindComplexity} characters, this may take some time.`,\n    );\n  }\n\n  // Run a loop until we that starts with the prefix and ends with the suffix\n  let counter = 0;\n  while (true) {\n    counter++;\n\n    // Log every 100,000 iterations\n    if (!options.silenceGrindProgress && counter % 100000 === 0) {\n      console.log(`Keypair grind tries: ${counter}`);\n    }\n\n    const keyPair = await crypto.subtle.generateKey(\n      \"Ed25519\", // Algorithm. Native implementation status: https://github.com/WICG/webcrypto-secure-curves/issues/20\n      allowExtractablePrivateKey, // Allows the private key to be exported (eg for saving it to a file) - public key is always extractable see https://wicg.github.io/webcrypto-secure-curves/#ed25519-operations\n      [\"sign\", \"verify\"], // Allowed uses\n    );\n\n    const publicKeyString = await getBase58AddressFromPublicKey(keyPair.publicKey);\n\n    // If we don't have a prefix, we don't need to check if the keyPair starts with the prefix\n    if (!options.prefix && !options.suffix) {\n      return keyPair;\n    }\n\n    const matchesPrefix = options.prefix ? publicKeyString.startsWith(options.prefix) : true;\n    const matchesSuffix = options.suffix ? publicKeyString.endsWith(options.suffix) : true;\n\n    // If the keyPair matches, return it\n    if (matchesPrefix && matchesSuffix) {\n      return keyPair;\n    }\n\n    // Restart the loop\n    continue;\n  }\n};\n\n// Take a webcrypto keyPair and convert it to the same format Anza CLI uses\n// 32 bytes raw private key followed by 32 bytes raw public key\n// (a bit odd, since the public key is usually derived from the private key, but\n// this is how NaCl / libsodium did it, and it saves a little time not having\n// to derive the public key from the private key)\nexport const createJSONFromKeyPairSigner = async (keyPairSigner: KeyPairSigner): Promise<string> => {\n  const rawPrivateKeyBytes = await exportRawPrivateKeyBytes(keyPairSigner.keyPair.privateKey);\n  const rawPublicKeyBytes = await exportRawPublicKeyBytes(keyPairSigner.keyPair.publicKey);\n\n  // Concatenate the raw private and public keys\n  const combinedArrayBuffer = new Uint8Array(KEYPAIR_LENGTH);\n  combinedArrayBuffer.set(new Uint8Array(rawPrivateKeyBytes), 0);\n  combinedArrayBuffer.set(new Uint8Array(rawPublicKeyBytes), KEYPAIR_PUBLIC_KEY_OFFSET);\n\n  return JSON.stringify(Array.from(combinedArrayBuffer));\n};\n\n/**\n * Loads a wallet (KeyPairSigner) from a file. The file should be in the same format as files created by the solana-keygen command.\n * @param {string} [filepath] - Path to load keypair from file. Defaults to ~/.config/solana/id.json\n * @returns {Promise<KeyPairSigner>} The loaded wallet\n */\nexport const loadWalletFromFile = async (filepath?: string): Promise<KeyPairSigner> => {\n  // Node-specific imports\n  const path = await import(\"node:path\");\n  const { readFile } = await import(\"node:fs/promises\");\n  // Work out correct file name\n  if (!filepath) {\n    filepath = DEFAULT_FILEPATH;\n  }\n  if (filepath[0] === \"~\") {\n    const home = process.env.HOME || null;\n    if (home) {\n      filepath = path.join(home, filepath.slice(1));\n    }\n  }\n\n  // Get contents of file\n  let fileContents: string;\n  try {\n    const fileContentsBuffer = await readFile(filepath);\n    fileContents = fileContentsBuffer.toString();\n  } catch (thrownObject) {\n    throw new Error(`Could not read keyPair from file at '${filepath}'`);\n  }\n\n  try {\n    // Parse file and return the keyPair\n    const parsedFileContents = Uint8Array.from(JSON.parse(fileContents));\n    return createKeyPairSignerFromBytes(parsedFileContents);\n  } catch (thrownObject) {\n    const error = thrownObject as Error;\n    if (!error.message.includes(\"Unexpected token\")) {\n      throw error;\n    }\n    throw new Error(`Invalid secret key file at '${filepath}'!`);\n  }\n};\n\n/**\n * Loads a wallet (KeyPairSigner) from an environment variable. The keypair should be in the same 'array of numbers' format as used by solana-keygen.\n * @param {string} variableName - Name of environment variable containing the keypair\n * @returns {KeyPairSigner} The loaded wallet\n */\nexport const loadWalletFromEnvironment = (variableName: string) => {\n  const privateKeyString = process.env[variableName];\n  if (!privateKeyString) {\n    throw new Error(`Please set '${variableName}' in environment.`);\n  }\n\n  try {\n    // If we wanted to, we could also support base58 encoded private keys\n    // let decodedPrivateKey = getBase58Encoder().encode(solanaPrivateKeyBase58)\n    // but the array-of-numbers format is the Anza CLI's format\n    let decodedPrivateKey = Uint8Array.from(JSON.parse(privateKeyString));\n    return createKeyPairSignerFromBytes(decodedPrivateKey);\n  } catch (error) {\n    throw new Error(`Invalid private key in environment variable '${variableName}'!`);\n  }\n};\n\nexport const addKeyPairSignerToEnvFile = async (\n  keyPairSigner: KeyPairSigner,\n  variableName: string,\n  envFileName?: string,\n) => {\n  // Node-specific imports\n  const { appendFile } = await import(\"node:fs/promises\");\n  if (!envFileName) {\n    envFileName = \".env\";\n  }\n  const existingSecretKey = process.env[variableName];\n  if (existingSecretKey) {\n    throw new Error(`'${variableName}' already exists in env file.`);\n  }\n  const privateKeyString = await createJSONFromKeyPairSigner(keyPairSigner);\n  await appendFile(envFileName, `\\n# Solana Address: ${keyPairSigner.address}\\n${variableName}=${privateKeyString}`);\n};\n","import { lamports, address as toAddress } from \"@solana/kit\";\n\n// General JS constants\nexport const NOT_FOUND = -1;\n\n// Some program names\nexport const TOKEN_PROGRAM = toAddress(\"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\");\nexport const TOKEN_EXTENSIONS_PROGRAM = toAddress(\"TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb\");\nexport const ASSOCIATED_TOKEN_PROGRAM = toAddress(\"ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL\");\n\n// Default values for making and loading wallets\nexport const SOL = 1_000_000_000n;\nexport const SECONDS = 1_000;\nexport const DEFAULT_AIRDROP_AMOUNT = lamports(1n * SOL);\nexport const DEFAULT_MINIMUM_BALANCE = lamports(500_000_000n);\nexport const DEFAULT_ENV_KEYPAIR_VARIABLE_NAME = \"PRIVATE_KEY\";\n\nexport const DEFAULT_TRANSACTION_RETRIES = 4;\nexport const DEFAULT_TRANSACTION_TIMEOUT = 15 * SECONDS;\n// Anza keys concatenate the 32 bytes raw private key and the 32 bytes raw public key.\n// This format was commonly used in NaCl / libsodium when they were popular.\nexport const KEYPAIR_LENGTH = 64;\nexport const KEYPAIR_PUBLIC_KEY_OFFSET = 32;\n\n// Default value from Solana CLI\nexport const DEFAULT_FILEPATH = \"~/.config/solana/id.json\";\n\nexport const BASE58_CHARACTER_SET = /^[1-9A-HJ-NP-Za-km-z]+$/;\n\n// 0x302e020100300506032b657004220420\n// See https://stackoverflow.com/questions/79134901/how-can-i-make-a-webcrypto-cryptokeypair-from-a-uint8array\n// TODO: add a better reference to a spec or ASN 1 decoding tool\nconst PKCS_8_PREFIX = new Uint8Array([48, 46, 2, 1, 0, 48, 5, 6, 3, 43, 101, 112, 4, 34, 4, 32]);\nexport const PKCS_8_PREFIX_LENGTH = PKCS_8_PREFIX.length;\n\nexport const GRIND_COMPLEXITY_THRESHOLD = 5;\n","import { PKCS_8_PREFIX_LENGTH } from \"./constants\";\nimport bs58 from \"bs58\";\n// Fixes \"Value of \"this\" must be of type SubtleCrypto\" errors\nconst exportKey = crypto.subtle.exportKey.bind(crypto.subtle);\n\n// Annoyingly we can't directly output the \"raw\" format value of a private key\n// (we have to use another format)\n// See https://wicg.github.io/webcrypto-secure-curves/#ed25519-operations\n// So let's strip out the PKCS8 prefix and return the raw bytes that follow\nexport const exportRawPrivateKeyBytes = async (privateKey: CryptoKey): Promise<Uint8Array> => {\n  if (!privateKey.extractable) {\n    throw new Error(\"Private key is not extractable\");\n  }\n  const pkcs8Bytes = await exportKey(\"pkcs8\", privateKey);\n  const rawPrivateKeyBytes = pkcs8Bytes.slice(PKCS_8_PREFIX_LENGTH);\n  return new Uint8Array(rawPrivateKeyBytes);\n};\n\nexport const exportRawPublicKeyBytes = async (publicKey: CryptoKey): Promise<Uint8Array> => {\n  // Note we don't need to check if the public key is extractable because it is always true\n  // See https://wicg.github.io/webcrypto-secure-curves/#ed25519-operations\n  const rawPublicKeyBytes = await exportKey(\"raw\", publicKey);\n  return new Uint8Array(rawPublicKeyBytes);\n};\n\nexport const getBase58AddressFromPublicKey = async (publicKey: CryptoKey): Promise<string> => {\n  const publicKeyBytes = await exportRawPublicKeyBytes(publicKey);\n  const publicKeyString = bs58.encode(publicKeyBytes);\n  return publicKeyString;\n};\n","// Make an object with a map of solana cluster names to subobjects, with the subobjects containing the URL and websocket URL\nexport const CLUSTERS: Record<\n  string,\n  {\n    httpURL: string;\n    webSocketURL: string;\n\n    // The URL param name required for this cluster (eg for API keys)\n    requiredParam: string | null;\n    // The environment variable name used for requiredParam above.\n    requiredParamEnvironmentVariable: string | null;\n\n    features: {\n      // Whether this is the default cluster for the Solana Explorer\n      isExplorerDefault: boolean;\n      // Whether this cluster name is known to the Solana Explorer\n      isNameKnownToSolanaExplorer: boolean;\n      // Whether this cluster supports Helius priority fee estimate instruction\n      // See https://docs.helius.dev/solana-apis/priority-fee-api\n      supportsGetPriorityFeeEstimate: boolean;\n      // Enable retries on the client side\n      enableClientSideRetries: boolean;\n      // Whether this cluster needs priority fees\n      needsPriorityFees: boolean;\n    };\n  }\n> = {\n  // Solana Labs RPCs\n  // Don't add a seperate entry for 'mainnet'. Instead, we'll correct the cluster name to 'mainnet-beta'\n  // in the connect function, and avoid making a duplicate entry.\n  \"mainnet-beta\": {\n    httpURL: \"https://api.mainnet-beta.solana.com\",\n    webSocketURL: \"wss://api.mainnet-beta.solana.com\",\n    requiredParam: null,\n    requiredParamEnvironmentVariable: null,\n    features: {\n      isExplorerDefault: true,\n      isNameKnownToSolanaExplorer: true,\n      supportsGetPriorityFeeEstimate: false,\n      enableClientSideRetries: true,\n      needsPriorityFees: true,\n    },\n  },\n  testnet: {\n    httpURL: \"https://api.testnet.solana.com\",\n    webSocketURL: \"wss://api.testnet.solana.com\",\n    requiredParam: null,\n    requiredParamEnvironmentVariable: null,\n    features: {\n      isExplorerDefault: false,\n      isNameKnownToSolanaExplorer: true,\n      supportsGetPriorityFeeEstimate: false,\n      enableClientSideRetries: true,\n      needsPriorityFees: true,\n    },\n  },\n  devnet: {\n    httpURL: \"https://api.devnet.solana.com\",\n    webSocketURL: \"wss://api.devnet.solana.com\",\n    requiredParam: null,\n    requiredParamEnvironmentVariable: null,\n    features: {\n      isExplorerDefault: false,\n      isNameKnownToSolanaExplorer: true,\n      supportsGetPriorityFeeEstimate: false,\n      enableClientSideRetries: true,\n      needsPriorityFees: true,\n    },\n  },\n  // Helius RPCs\n  \"helius-mainnet\": {\n    httpURL: \"https://mainnet.helius-rpc.com/\",\n    webSocketURL: \"wss://mainnet.helius-rpc.com/\",\n    requiredParam: \"api-key\",\n    requiredParamEnvironmentVariable: \"HELIUS_API_KEY\",\n    features: {\n      isExplorerDefault: false,\n      isNameKnownToSolanaExplorer: false,\n      supportsGetPriorityFeeEstimate: true,\n      enableClientSideRetries: true,\n      needsPriorityFees: true,\n    },\n  },\n  \"helius-devnet\": {\n    httpURL: \"https://devnet.helius-rpc.com/\",\n    webSocketURL: \"wss://devnet.helius-rpc.com/\",\n    requiredParam: \"api-key\",\n    requiredParamEnvironmentVariable: \"HELIUS_API_KEY\",\n    features: {\n      isExplorerDefault: false,\n      isNameKnownToSolanaExplorer: false,\n      supportsGetPriorityFeeEstimate: false,\n      enableClientSideRetries: true,\n      needsPriorityFees: true,\n    },\n  },\n  // Localnet\n  localnet: {\n    httpURL: \"http://localhost:8899\",\n    webSocketURL: \"ws://localhost:8900\",\n    requiredParam: null,\n    requiredParamEnvironmentVariable: null,\n    features: {\n      isExplorerDefault: false,\n      isNameKnownToSolanaExplorer: false,\n      supportsGetPriorityFeeEstimate: false,\n      enableClientSideRetries: false,\n      needsPriorityFees: false,\n    },\n  },\n};\n\nexport const KNOWN_CLUSTER_NAMES = Object.keys(CLUSTERS);\n\n// For error messages\nexport const KNOWN_CLUSTER_NAMES_STRING = KNOWN_CLUSTER_NAMES.join(\", \");\n","import {\n  appendTransactionMessageInstructions,\n  Commitment,\n  createSolanaRpcFromTransport,\n  createTransactionMessage,\n  getSignatureFromTransaction,\n  IInstruction,\n  KeyPairSigner,\n  pipe,\n  sendAndConfirmTransactionFactory,\n  setTransactionMessageFeePayerSigner,\n  setTransactionMessageLifetimeUsingBlockhash,\n  signTransactionMessageWithSigners,\n} from \"@solana/kit\";\nimport { getComputeUnitEstimate, getPriorityFeeEstimate, sendTransactionWithRetries } from \"./smart-transactions\";\nimport { getSetComputeUnitLimitInstruction, getSetComputeUnitPriceInstruction } from \"@solana-program/compute-budget\";\nimport { DEFAULT_TRANSACTION_RETRIES } from \"./constants\";\nimport { getErrorMessageFromLogs } from \"./logs\";\n\nexport interface ErrorWithTransaction extends Error {\n  // We add this ourselves, so users can see logs etc\n  transaction: Awaited<ReturnType<ReturnType<typeof createSolanaRpcFromTransport>[\"getTransaction\"]>>;\n  // This is added by @solana/kit\n  context: {\n    __code: number;\n    code: number;\n    index: number;\n  };\n}\n\nexport const sendTransactionFromInstructionsFactory = (\n  rpc: ReturnType<typeof createSolanaRpcFromTransport>,\n  needsPriorityFees: boolean,\n  supportsGetPriorityFeeEstimate: boolean,\n  enableClientSideRetries: boolean,\n  sendAndConfirmTransaction: ReturnType<typeof sendAndConfirmTransactionFactory>,\n) => {\n  const sendTransactionFromInstructions = async ({\n    feePayer,\n    instructions,\n    commitment = \"confirmed\",\n    skipPreflight = true,\n    maximumClientSideRetries = enableClientSideRetries ? DEFAULT_TRANSACTION_RETRIES : 0,\n    abortSignal = null,\n  }: {\n    feePayer: KeyPairSigner;\n    instructions: Array<IInstruction>;\n    commitment?: Commitment;\n    skipPreflight?: boolean;\n    maximumClientSideRetries?: number;\n    abortSignal?: AbortSignal | null;\n  }) => {\n    const { value: latestBlockhash } = await rpc.getLatestBlockhash().send({ abortSignal });\n\n    let transactionMessage = pipe(\n      createTransactionMessage({ version: 0 }),\n      (message) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, message),\n      (message) => setTransactionMessageFeePayerSigner(feePayer, message),\n      (message) => appendTransactionMessageInstructions(instructions, message),\n    );\n\n    if (needsPriorityFees) {\n      const [priorityFeeEstimate, computeUnitEstimate] = await Promise.all([\n        getPriorityFeeEstimate(rpc, supportsGetPriorityFeeEstimate, transactionMessage, abortSignal),\n        getComputeUnitEstimate(rpc, transactionMessage, abortSignal),\n      ]);\n\n      const setComputeUnitPriceInstruction = getSetComputeUnitPriceInstruction({\n        microLamports: BigInt(priorityFeeEstimate),\n      });\n\n      const setComputeUnitLimitInstruction = getSetComputeUnitLimitInstruction({\n        units: Math.ceil(computeUnitEstimate * 1.1),\n      });\n\n      transactionMessage = appendTransactionMessageInstructions(\n        [setComputeUnitPriceInstruction, setComputeUnitLimitInstruction],\n        transactionMessage,\n      );\n    }\n\n    const signedTransaction = await signTransactionMessageWithSigners(transactionMessage);\n\n    const signature = getSignatureFromTransaction(signedTransaction);\n\n    try {\n      if (maximumClientSideRetries) {\n        await sendTransactionWithRetries(sendAndConfirmTransaction, signedTransaction, {\n          maximumClientSideRetries,\n          abortSignal,\n          commitment,\n        });\n      } else {\n        await sendAndConfirmTransaction(signedTransaction, {\n          commitment,\n          skipPreflight,\n        });\n      }\n    } catch (thrownObject) {\n      const error = thrownObject as ErrorWithTransaction;\n\n      const transaction = await rpc\n        .getTransaction(signature, {\n          commitment,\n          maxSupportedTransactionVersion: 0,\n        })\n        .send();\n\n      error.transaction = transaction;\n\n      // If we have a custom program error, try to find a better error message in the logs\n      // TODO: honestly this should be fixed upstream in @solana/kit\n      if (error.message.includes(\"custom program error\") && transaction.meta?.logMessages) {\n        const betterMessage = getErrorMessageFromLogs(transaction.meta.logMessages);\n        if (betterMessage) {\n          error.message = betterMessage;\n        }\n      }\n\n      throw error;\n    }\n\n    return signature;\n  };\n  return sendTransactionFromInstructions;\n};\n","// Based on smart-transaction.ts from https://github.com/mcintyre94/helius-smart-transactions-web3js2\n\nimport {\n  IInstruction,\n  getComputeUnitEstimateForTransactionMessageFactory,\n  appendTransactionMessageInstruction,\n  TransactionMessage,\n  isWritableRole,\n  isInstructionWithData,\n  CompilableTransactionMessage,\n  createSolanaRpcFromTransport,\n  sendAndConfirmTransactionFactory,\n  TransactionWithBlockhashLifetime,\n  FullySignedTransaction,\n  Commitment,\n  SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED,\n  isSolanaError,\n} from \"@solana/kit\";\nimport {\n  getSetComputeUnitPriceInstruction,\n  identifyComputeBudgetInstruction,\n  COMPUTE_BUDGET_PROGRAM_ADDRESS,\n  ComputeBudgetInstruction,\n} from \"@solana-program/compute-budget\";\nimport { getAbortablePromise } from \"@solana/promises\";\nimport { DEFAULT_TRANSACTION_RETRIES, DEFAULT_TRANSACTION_TIMEOUT } from \"./constants\";\n\nexport const getPriorityFeeEstimate = async (\n  rpc: ReturnType<typeof createSolanaRpcFromTransport>,\n  supportsGetPriorityFeeEstimate: boolean,\n  transactionMessage: TransactionMessage,\n  abortSignal: AbortSignal | null = null,\n): Promise<number> => {\n  const accountKeys = [\n    ...new Set([\n      ...transactionMessage.instructions.flatMap((instruction: IInstruction) =>\n        (instruction.accounts ?? [])\n          .filter((account) => isWritableRole(account.role))\n          .map((account) => account.address),\n      ),\n    ]),\n  ];\n\n  // If the RPC doesn't support getPriorityFeeEstimate, use the median of the recent fees\n  if (!supportsGetPriorityFeeEstimate) {\n    const recentFeesResponse = await rpc.getRecentPrioritizationFees([...accountKeys]).send({ abortSignal });\n    // @ts-expect-error TODO: typing error from original helius-smart-transactions-web3js2. Fix this.\n    const recentFeesValues = recentFeesResponse.reduce((accumulator, current) => {\n      if (current.prioritizationFee > 0n) {\n        return [...accumulator, current.prioritizationFee];\n      } else {\n        return accumulator;\n      }\n    }, []);\n\n    // Return the median fee\n    // @ts-expect-error TODO: typing error from original helius-smart-transactions-web3js2. Fix this.\n    recentFeesValues.sort((a, b) => Number(a - b));\n    return Number(recentFeesValues[Math.floor(recentFeesValues.length / 2)]);\n  }\n  // Get a priority fee estimate, using Helius' `getPriorityFeeEstimate` method on Helius mainnet\n\n  const { priorityFeeEstimate } = await rpc\n    .getPriorityFeeEstimate({\n      accountKeys,\n      options: {\n        // See https://docs.helius.dev/solana-apis/priority-fee-api\n        // Per Evan at Helius 20250213: recommended: true is not longer preferred,\n        // instead use priorityLevel: \"High\"\n        priorityLevel: \"High\",\n      },\n    })\n    .send({ abortSignal });\n\n  return priorityFeeEstimate;\n};\n\nexport const getComputeUnitEstimate = async (\n  rpc: ReturnType<typeof createSolanaRpcFromTransport>,\n  transactionMessage: CompilableTransactionMessage,\n  abortSignal: AbortSignal | null = null,\n) => {\n  // add placeholder instruction for CU price if not already present\n  // web3js estimate will add CU limit but not price\n  // both take CUs, so we need both in the simulation\n  const hasExistingComputeBudgetPriceInstruction = transactionMessage.instructions.some(\n    (instruction) =>\n      instruction.programAddress === COMPUTE_BUDGET_PROGRAM_ADDRESS &&\n      isInstructionWithData(instruction) &&\n      identifyComputeBudgetInstruction(instruction) === ComputeBudgetInstruction.SetComputeUnitPrice,\n  );\n\n  const transactionMessageToSimulate = hasExistingComputeBudgetPriceInstruction\n    ? transactionMessage\n    : appendTransactionMessageInstruction(getSetComputeUnitPriceInstruction({ microLamports: 0n }), transactionMessage);\n\n  const computeUnitEstimateFn = getComputeUnitEstimateForTransactionMessageFactory({ rpc });\n  // TODO: computeUnitEstimateFn expects an explicit 'undefined' for abortSignal,\n  // fix upstream\n  return computeUnitEstimateFn(transactionMessageToSimulate, {\n    abortSignal: abortSignal ?? undefined,\n  });\n};\n\nexport const sendTransactionWithRetries = async (\n  sendAndConfirmTransaction: ReturnType<typeof sendAndConfirmTransactionFactory>,\n  transaction: FullySignedTransaction & TransactionWithBlockhashLifetime,\n  options: {\n    maximumClientSideRetries: number;\n    abortSignal: AbortSignal | null;\n    commitment: Commitment;\n  } = {\n    maximumClientSideRetries: DEFAULT_TRANSACTION_RETRIES,\n    abortSignal: null,\n    commitment: \"confirmed\",\n  },\n) => {\n  let retriesLeft = options.maximumClientSideRetries;\n\n  const transactionOptions = {\n    // TODO: web3.js wants explicit undefineds. Fix upstream.\n    abortSignal: options.abortSignal || undefined,\n    commitment: options.commitment,\n    // This is the server-side retries and should always be 0.\n    // We will do retries here on the client.\n    // See https://docs.helius.dev/solana-rpc-nodes/sending-transactions-on-solana#sending-transactions-without-the-sdk\n    maxRetries: 0n,\n  };\n\n  while (retriesLeft) {\n    try {\n      const txPromise = sendAndConfirmTransaction(transaction, transactionOptions);\n      await getAbortablePromise(txPromise, AbortSignal.timeout(DEFAULT_TRANSACTION_TIMEOUT));\n      break;\n    } catch (error) {\n      if (error instanceof DOMException && error.name === \"TimeoutError\") {\n        // timeout error happens if the transaction is not confirmed in DEFAULT_TRANSACTION_TIMEOUT\n        // we can retry until we run out of retries\n        console.debug(\"Transaction not confirmed, retrying...\");\n      } else if (isSolanaError(error, SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED)) {\n        // race condition where the transaction is processed between throwing the\n        // `TimeoutError` and our next retry\n        break;\n      } else {\n        throw error;\n      }\n    } finally {\n      retriesLeft--;\n    }\n  }\n};\n","/**\n * Forked from https://github.com/digitalloggers/race-as-promised/tree/master\n *\n * Authored by Brian Kim:\n * https://github.com/nodejs/node/issues/17469#issuecomment-685216777\n *\n * Adapted to module structure.\n *\n * This is free and unencumbered software released into the public domain.\n *\n * Anyone is free to copy, modify, publish, use, compile, sell, or\n * distribute this software, either in source code form or as a compiled\n * binary, for any purpose, commercial or non-commercial, and by any\n * means.\n *\n * In jurisdictions that recognize copyright laws, the author or authors\n * of this software dedicate any and all copyright interest in the\n * software to the public domain. We make this dedication for the benefit\n * of the public at large and to the detriment of our heirs and\n * successors. We intend this dedication to be an overt act of\n * relinquishment in perpetuity of all present and future rights to this\n * software under copyright law.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * For more information, please refer to <http://unlicense.org/>\n */\n\ntype Deferred = Readonly<{\n    reject: (reason?: unknown) => void;\n    resolve: (value: unknown) => void;\n}>;\n\nfunction isObject(value: unknown): value is object {\n    return value !== null && (typeof value === 'object' || typeof value === 'function');\n}\n\nfunction addRaceContender(contender: object) {\n    const deferreds = new Set<Deferred>();\n    const record = { deferreds, settled: false };\n\n    // This call to `then` happens once for the lifetime of the value.\n    Promise.resolve(contender).then(\n        value => {\n            for (const { resolve } of deferreds) {\n                resolve(value);\n            }\n\n            deferreds.clear();\n            record.settled = true;\n        },\n        err => {\n            for (const { reject } of deferreds) {\n                reject(err);\n            }\n\n            deferreds.clear();\n            record.settled = true;\n        },\n    );\n    return record;\n}\n\n// Keys are the values passed to race, values are a record of data containing a\n// set of deferreds and whether the value has settled.\nconst wm = new WeakMap<object, { deferreds: Set<Deferred>; settled: boolean }>();\nexport async function safeRace<T extends readonly unknown[] | []>(contenders: T): Promise<Awaited<T[number]>> {\n    let deferred: Deferred;\n    const result = new Promise((resolve, reject) => {\n        deferred = { reject, resolve };\n        for (const contender of contenders) {\n            if (!isObject(contender)) {\n                // If the contender is a primitive, attempting to use it as a key in the\n                // weakmap would throw an error. Luckily, it is safe to call\n                // `Promise.resolve(contender).then` on a primitive value multiple times\n                // because the promise fulfills immediately.\n                Promise.resolve(contender).then(resolve, reject);\n                continue;\n            }\n\n            let record = wm.get(contender);\n            if (record === undefined) {\n                record = addRaceContender(contender);\n                record.deferreds.add(deferred);\n                wm.set(contender, record);\n            } else if (record.settled) {\n                // If the value has settled, it is safe to call\n                // `Promise.resolve(contender).then` on it.\n                Promise.resolve(contender).then(resolve, reject);\n            } else {\n                record.deferreds.add(deferred);\n            }\n        }\n    });\n\n    // The finally callback executes when any value settles, preventing any of\n    // the unresolved values from retaining a reference to the resolved value.\n    return await (result.finally(() => {\n        for (const contender of contenders) {\n            if (isObject(contender)) {\n                const record = wm.get(contender)!;\n                record.deferreds.delete(deferred);\n            }\n        }\n    }) as Promise<Awaited<T[number]>>);\n}\n","import { safeRace } from './race';\n\nexport function getAbortablePromise<T>(promise: Promise<T>, abortSignal?: AbortSignal): Promise<T> {\n    if (!abortSignal) {\n        return promise;\n    } else {\n        return safeRace([\n            // This promise only ever rejects if the signal is aborted. Otherwise it idles forever.\n            // It's important that this come before the input promise; in the event of an abort, we\n            // want to throw even if the input promise's result is ready\n            new Promise<never>((_, reject) => {\n                if (abortSignal.aborted) {\n                    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                    reject(abortSignal.reason);\n                } else {\n                    abortSignal.addEventListener('abort', function () {\n                        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                        reject(this.reason);\n                    });\n                }\n            }),\n            promise,\n        ]);\n    }\n}\n","import { createSolanaRpcFromTransport } from \"@solana/kit\";\nimport { NOT_FOUND } from \"./constants\";\n\nexport const getLogsFactory = (rpc: ReturnType<typeof createSolanaRpcFromTransport>) => {\n  /**\n   * Retrieves logs for a transaction.\n   * @param {string} signature - Transaction signature to get logs for\n   * @returns {Promise<Array<string>>} Array of log messages from the transaction\n   */\n  const getLogs = async (signature: string): Promise<Array<string>> => {\n    const transaction = await rpc\n      .getTransaction(signature, {\n        commitment: \"confirmed\",\n        maxSupportedTransactionVersion: 0,\n      })\n      .send();\n\n    if (!transaction?.meta) {\n      throw new Error(`Transaction not found: ${signature}`);\n    }\n\n    return transaction.meta.logMessages ?? [];\n  };\n  return getLogs;\n};\n\n/**\n * Extracts a user-friendly error message from transaction logs.\n * @param logMessages Array of log messages from the transaction\n * @returns A formatted error message in the format \"programAddress.instructionName: errorMessage\" or null if no error found\n */\nexport const getErrorMessageFromLogs = (logMessages: Array<string>): string | null => {\n  // First try to find an Anchor error\n  // Pattern:\n  // \"Program <program> invoke [n]\"\n  // \"Program log: Instruction: <instruction>\"\n  // \"Program log: AnchorError caused by account: <account>. Error Code: <code>. Error Number: <number>. Error Message: <message>\"\n  const anchorErrorIndex = logMessages.findIndex((logMessage: string) =>\n    logMessage.includes(\"Program log: AnchorError caused by account:\"),\n  );\n\n  if (anchorErrorIndex !== NOT_FOUND) {\n    // Get the program name from the invoke log (usually 2 lines before the error)\n    const programInvokeLog = logMessages[anchorErrorIndex - 2];\n    const programName = programInvokeLog?.split(\"Program \")[1]?.split(\" invoke\")[0];\n\n    // Get the instruction name from the instruction log (usually 1 line before the error)\n    const instructionHandlerLog = logMessages[anchorErrorIndex - 1];\n    const instructionHandlerName = instructionHandlerLog?.split(\"Instruction: \")[1];\n\n    // Get the error message from the Anchor error log\n    const errorMessage = logMessages[anchorErrorIndex].split(\"Error Message: \")[1]?.split(\".\")[0]?.trim();\n\n    if (!errorMessage || !programName || !instructionHandlerName) {\n      return null;\n    }\n\n    return `${programName}.${instructionHandlerName}: ${errorMessage}`;\n  }\n\n  // If no Anchor error found, look for regular error\n  // Pattern:\n  // \"Program <program> invoke [n]\"\n  // \"Program log: Instruction: <instruction>\"\n  // \"Program log: Error: <error>\"\n  const errorIndex = logMessages.findIndex((logMessage: string) => logMessage.includes(\"Program log: Error: \"));\n\n  if (errorIndex !== NOT_FOUND) {\n    // Get the program name from the invoke log (usually 2 lines before the error)\n    const programInvokeLog = logMessages[errorIndex - 2];\n    const programName = programInvokeLog?.split(\"Program \")[1]?.split(\" invoke\")[0];\n\n    // Get the instruction name from the instruction log (usually 1 line before the error)\n    const instructionHandlerLog = logMessages[errorIndex - 1];\n    const instructionHandlerName = instructionHandlerLog?.split(\"Instruction: \")[1];\n\n    // Get the error message\n    const errorMessage = logMessages[errorIndex].split(\"Program log: Error: \")[1]?.trim();\n\n    if (!errorMessage || !programName || !instructionHandlerName) {\n      return null;\n    }\n\n    return `${programName}.${instructionHandlerName}: ${errorMessage}`;\n  }\n\n  // If no regular error found, look for system program error\n  // Pattern:\n  // \"Program <program> invoke [n]\"\n  // \"<instruction>: <error>\"\n  const systemErrorIndex = logMessages.findIndex(\n    (logMessage: string) =>\n      logMessage.includes(\": \") &&\n      !logMessage.includes(\"Program log:\") &&\n      !logMessage.includes(\"Program \") &&\n      !logMessage.includes(\" consumed \") &&\n      !logMessage.includes(\" success\") &&\n      !logMessage.includes(\" failed:\"),\n  );\n\n  if (systemErrorIndex !== NOT_FOUND) {\n    // Get the program name from the invoke log (usually 1 line before the error)\n    const programInvokeLog = logMessages[systemErrorIndex - 1];\n    const programName = programInvokeLog?.split(\"Program \")[1]?.split(\" invoke\")[0];\n\n    // Get the instruction name and error message from the error log\n    const [instructionName, ...errorParts] = logMessages[systemErrorIndex].split(\": \");\n    const errorMessage = errorParts.join(\": \");\n\n    if (!errorMessage || !programName || !instructionName) {\n      return null;\n    }\n\n    // For system program errors, we want to keep the full error message\n    // but remove the address details if present\n    const cleanErrorMessage = errorMessage\n      .replace(/Address {[^}]*}/, \"\")\n      .replace(/\\s+/g, \" \")\n      .trim();\n\n    return `${programName}.${instructionName}: ${cleanErrorMessage}`;\n  }\n\n  return null;\n};\n","import { createSignerFromKeyPair, KeyPairSigner, Lamports } from \"@solana/kit\";\nimport { DEFAULT_AIRDROP_AMOUNT, DEFAULT_ENV_KEYPAIR_VARIABLE_NAME } from \"./constants\";\nimport { addKeyPairSignerToEnvFile, grindKeyPair, loadWalletFromEnvironment } from \"./keypair\";\nimport dotenv from \"dotenv\";\nimport { airdropIfRequiredFactory } from \"./sol\";\n\nexport const createWalletFactory = (airdropIfRequired: ReturnType<typeof airdropIfRequiredFactory>) => {\n  const createWallet = async (\n    options: {\n      prefix?: string | null;\n      suffix?: string | null;\n      envFileName?: string | null;\n      envVariableName?: string;\n      airdropAmount?: Lamports | null;\n    } = {},\n  ): Promise<KeyPairSigner> => {\n    // If the user wants to save to an env variable, we need to save to a file\n    if (options.envVariableName && !options.envFileName) {\n      options.envFileName = \".env\";\n    }\n\n    const {\n      prefix = null,\n      suffix = null,\n      envFileName = null,\n      envVariableName = DEFAULT_ENV_KEYPAIR_VARIABLE_NAME,\n      airdropAmount = DEFAULT_AIRDROP_AMOUNT,\n    } = options;\n\n    let keyPairSigner: KeyPairSigner;\n\n    if (envFileName) {\n      // Important: we make a temporary extractable keyPair and write it to the environment file\n      // We then reload the keypair from the environment as non-extractable\n      // This is because the temporaryExtractableKeyPair's private key is extractable, and we want to keep it secret\n      const temporaryExtractableKeyPair = await grindKeyPair({\n        prefix,\n        suffix,\n        silenceGrindProgress: false,\n        isPrivateKeyExtractable:\n          \"yes I understand the risk of extractable private keys and will delete this keypair shortly after saving it to a file\",\n      });\n      const temporaryExtractableKeyPairSigner = await createSignerFromKeyPair(temporaryExtractableKeyPair);\n      await addKeyPairSignerToEnvFile(temporaryExtractableKeyPairSigner, envVariableName, envFileName);\n      dotenv.config({ path: envFileName });\n      keyPairSigner = await loadWalletFromEnvironment(envVariableName);\n      // Once the block is exited, the variable will be dereferenced and no longer accessible. This means the memory used by the variable can be reclaimed by the garbage collector, as there are no other references to it outside the block. Goodbye temporaryExtractableKeyPair and temporaryExtractableKeyPairSigner!\n    } else {\n      const keyPair = await grindKeyPair({\n        prefix,\n        suffix,\n      });\n      keyPairSigner = await createSignerFromKeyPair(keyPair);\n    }\n\n    if (airdropAmount) {\n      // Since this is a brand new wallet (and has no existing balance), we can just use the airdrop amount for the minimum balance\n      await airdropIfRequired(keyPairSigner.address, airdropAmount, airdropAmount);\n    }\n\n    return keyPairSigner;\n  };\n\n  return createWallet;\n};\n\n// See https://assets.fengsi.io/pr:sharp/rs:fill:1600:1067:1:1/g:ce/q:80/L2FwaS9qZGxlYXRoZXJnb29kcy9vcmlnaW5hbHMvYjZmNmU2ODAtNzY3OC00MDFiLWE1MzctODg4MWQyMmMzZWIyLmpwZw.jpg\nexport const createWalletsFactory = (createWallet: ReturnType<typeof createWalletFactory>) => {\n  const createWallets = (\n    amount: number,\n    options: Parameters<ReturnType<typeof createWalletFactory>>[0],\n  ): Promise<Array<KeyPairSigner>> => {\n    const walletPromises = Array.from({ length: amount }, () => createWallet(options));\n    return Promise.all(walletPromises);\n  };\n  return createWallets;\n};\n","import { Commitment, generateKeyPairSigner, Lamports, some } from \"@solana/kit\";\nimport { Address } from \"@solana/kit\";\nimport {\n  // This is badly named. It's a function that returns an object.\n  extension as getExtensionData,\n  findAssociatedTokenPda,\n  getCreateAssociatedTokenInstructionAsync,\n  getInitializeMetadataPointerInstruction,\n  getInitializeMintInstruction,\n  getInitializeTokenMetadataInstruction,\n  getMintSize,\n  getMintToInstruction,\n  getUpdateTokenMetadataFieldInstruction,\n  tokenMetadataField,\n  getTransferCheckedInstruction,\n  fetchMint,\n  getCreateAssociatedTokenInstruction,\n} from \"@solana-program/token-2022\";\nimport { createSolanaRpcFromTransport, KeyPairSigner } from \"@solana/kit\";\nimport { sendTransactionFromInstructionsFactory } from \"./transactions\";\nimport { getCreateAccountInstruction, getTransferSolInstruction } from \"@solana-program/system\";\nimport { TOKEN_PROGRAM } from \"./constants\";\nimport { TOKEN_EXTENSIONS_PROGRAM } from \"./constants\";\n\nexport const transferLamportsFactory = (\n  sendTransactionFromInstructions: ReturnType<typeof sendTransactionFromInstructionsFactory>,\n) => {\n  const transferLamports = async ({\n    source,\n    destination,\n    amount,\n    skipPreflight = true,\n    maximumClientSideRetries = 0,\n    abortSignal = null,\n  }: {\n    source: KeyPairSigner;\n    destination: Address;\n    amount: Lamports;\n    skipPreflight?: boolean;\n    maximumClientSideRetries?: number;\n    abortSignal?: AbortSignal | null;\n  }) => {\n    const instruction = getTransferSolInstruction({\n      amount,\n      destination: destination,\n      source: source,\n    });\n\n    const signature = await sendTransactionFromInstructions({\n      feePayer: source,\n      instructions: [instruction],\n      commitment: \"confirmed\",\n      skipPreflight,\n      maximumClientSideRetries,\n      abortSignal,\n    });\n\n    return signature;\n  };\n  return transferLamports;\n};\n\nexport const transferTokensFactory = (\n  getMint: ReturnType<typeof getMintFactory>,\n  sendTransactionFromInstructions: ReturnType<typeof sendTransactionFromInstructionsFactory>,\n) => {\n  const transferTokens = async ({\n    sender,\n    destination,\n    mintAddress,\n    amount,\n    maximumClientSideRetries = 0,\n    abortSignal = null,\n  }: {\n    sender: KeyPairSigner;\n    destination: Address;\n    mintAddress: Address;\n    amount: bigint;\n    maximumClientSideRetries?: number;\n    abortSignal?: AbortSignal | null;\n  }) => {\n    const mint = await getMint(mintAddress);\n\n    if (!mint) {\n      throw new Error(`Mint not found: ${mintAddress}`);\n    }\n\n    const decimals = mint.data.decimals;\n\n    const sourceAssociatedTokenAddress = await getTokenAccountAddress(sender.address, mintAddress, true);\n\n    const destinationAssociatedTokenAddress = await getTokenAccountAddress(destination, mintAddress, true);\n\n    // Create an associated token account for the receiver\n    const createAssociatedTokenInstruction = getCreateAssociatedTokenInstruction({\n      ata: destinationAssociatedTokenAddress,\n      mint: mintAddress,\n      owner: destination,\n      payer: sender,\n    });\n\n    const transferInstruction = getTransferCheckedInstruction({\n      source: sourceAssociatedTokenAddress,\n      mint: mintAddress,\n      destination: destinationAssociatedTokenAddress,\n      authority: sender.address,\n      amount,\n      decimals,\n    });\n\n    const signature = await sendTransactionFromInstructions({\n      feePayer: sender,\n      instructions: [createAssociatedTokenInstruction, transferInstruction],\n      commitment: \"confirmed\",\n      skipPreflight: true,\n      maximumClientSideRetries,\n      abortSignal,\n    });\n\n    return signature;\n  };\n  return transferTokens;\n};\n\n/**\n * Gets the address where a wallet's tokens are stored.\n * Each wallet has a unique storage address for each type of token.\n * @param {Address} wallet - The wallet that owns the tokens\n * @param {Address} mint - The type of token\n * @param {boolean} [useTokenExtensions=false] - Use Token Extensions program instead of classic Token program\n * @returns {Promise<Address>} The token account address\n */\nexport const getTokenAccountAddress = async (wallet: Address, mint: Address, useTokenExtensions: boolean = false) => {\n  const tokenProgram = useTokenExtensions ? TOKEN_EXTENSIONS_PROGRAM : TOKEN_PROGRAM;\n\n  // Slightly misnamed, it returns an address and a seed\n  const [address] = await findAssociatedTokenPda({\n    mint: mint,\n    owner: wallet,\n    tokenProgram,\n  });\n\n  return address;\n};\n\nexport const createTokenMintFactory = (\n  rpc: ReturnType<typeof createSolanaRpcFromTransport>,\n  sendTransactionFromInstructions: ReturnType<typeof sendTransactionFromInstructionsFactory>,\n): ((params: {\n  mintAuthority: KeyPairSigner;\n  decimals: number;\n  name: string;\n  symbol: string;\n  uri: string;\n  additionalMetadata?: Record<string, string> | Map<string, string>;\n}) => Promise<Address>) => {\n  const createTokenMint = async ({\n    mintAuthority,\n    decimals,\n    name,\n    symbol,\n    uri,\n    additionalMetadata = {},\n  }: {\n    mintAuthority: KeyPairSigner;\n    decimals: number;\n    name: string;\n    symbol: string;\n    uri: string;\n    additionalMetadata?: Record<string, string> | Map<string, string>;\n  }) => {\n    // See https://solana.stackexchange.com/questions/19747/how-do-i-make-a-token-with-metadata-using-web3-js-version-2/19792#19792 - big thanks to John for helping me turn the unit tests into a working example\n\n    // Generate keypairs for and mint\n    const mint = await generateKeyPairSigner();\n\n    // Convert additionalMetadata to a Map if it's a Record\n    const additionalMetadataMap =\n      additionalMetadata instanceof Map ? additionalMetadata : new Map(Object.entries(additionalMetadata));\n\n    // Metadata Pointer Extension Data\n    // Storing metadata directly in the mint account\n    const metadataPointerExtensionData = getExtensionData(\"MetadataPointer\", {\n      authority: some(mintAuthority.address),\n      metadataAddress: some(mint.address),\n    });\n\n    // Token Metadata Extension Data\n    // Using this to calculate rent lamports up front\n    const tokenMetadataExtensionData = getExtensionData(\"TokenMetadata\", {\n      updateAuthority: some(mintAuthority.address),\n      mint: mint.address,\n      name,\n      symbol,\n      uri,\n      additionalMetadata: additionalMetadataMap,\n    });\n\n    // The amount of space required to initialize the mint account (with metadata pointer extension only)\n    // Excluding the metadata extension intentionally\n    // The metadata extension instruction MUST come after initialize mint instruction,\n    // Including space for the metadata extension will result in\n    // error: \"invalid account data for instruction\" when the initialize mint instruction is processed\n    const spaceWithoutMetadata = BigInt(getMintSize([metadataPointerExtensionData]));\n\n    // The amount of space required for the mint account and both extensions\n    // Use to calculate total rent lamports that must be allocated to the mint account\n    // The metadata extension instruction automatically does the space reallocation,\n    // but DOES NOT transfer the rent lamports required to store the extra metadata\n    const spaceWithMetadata = BigInt(getMintSize([metadataPointerExtensionData, tokenMetadataExtensionData]));\n\n    // Calculate rent lamports for mint account with metadata pointer and token metadata extensions\n    const rent = await rpc.getMinimumBalanceForRentExemption(spaceWithMetadata).send();\n\n    // Instruction to create new account for mint (Token Extensions program)\n    // space: only for mint and metadata pointer extension, other wise initialize instruction will fail\n    // lamports: for mint, metadata pointer extension, and token metadata extension (paying up front for simplicity)\n    const createAccountInstruction = getCreateAccountInstruction({\n      payer: mintAuthority,\n      newAccount: mint,\n      lamports: rent,\n      space: spaceWithoutMetadata,\n      programAddress: TOKEN_EXTENSIONS_PROGRAM,\n    });\n\n    // Instruction to initialize metadata pointer extension\n    // This instruction must come before initialize mint instruction\n    const initializeMetadataPointerInstruction = getInitializeMetadataPointerInstruction({\n      mint: mint.address,\n      authority: mintAuthority.address,\n      metadataAddress: mint.address,\n    });\n\n    // Instruction to initialize base mint account data\n    const initializeMintInstruction = getInitializeMintInstruction({\n      mint: mint.address,\n      decimals,\n      mintAuthority: mintAuthority.address,\n    });\n\n    // Instruction to initialize token metadata extension\n    // This instruction must come after initialize mint instruction\n    // This ONLY initializes basic metadata fields (name, symbol, uri)\n    const initializeTokenMetadataInstruction = getInitializeTokenMetadataInstruction({\n      metadata: mint.address,\n      updateAuthority: mintAuthority.address,\n      mint: mint.address,\n      mintAuthority: mintAuthority,\n      name: tokenMetadataExtensionData.name,\n      symbol: tokenMetadataExtensionData.symbol,\n      uri: tokenMetadataExtensionData.uri,\n    });\n\n    // Instruction to update token metadata extension\n    // This either updates existing fields or adds the custom additionalMetadata fields\n    const updateTokenMetadataInstruction = getUpdateTokenMetadataFieldInstruction({\n      metadata: mint.address,\n      updateAuthority: mintAuthority,\n      field: tokenMetadataField(\"Key\", [\"description\"]),\n      value: \"Only Possible On Solana\",\n    });\n\n    // Order of instructions to add to transaction\n    const instructions = [\n      createAccountInstruction,\n      initializeMetadataPointerInstruction,\n      initializeMintInstruction,\n      initializeTokenMetadataInstruction,\n      updateTokenMetadataInstruction,\n    ];\n\n    await sendTransactionFromInstructions({\n      feePayer: mintAuthority,\n      instructions,\n    });\n\n    return mint.address;\n  };\n\n  return createTokenMint;\n};\n\nexport const mintTokensFactory = (\n  sendTransactionFromInstructions: ReturnType<typeof sendTransactionFromInstructionsFactory>,\n) => {\n  const mintTokens = async (\n    mintAddress: Address,\n    mintAuthority: KeyPairSigner,\n    amount: bigint,\n    destination: Address,\n  ) => {\n    // Create Associated Token Account\n    const createAtaInstruction = await getCreateAssociatedTokenInstructionAsync({\n      payer: mintAuthority,\n      mint: mintAddress,\n      owner: destination,\n    });\n\n    // Derive destination associated token address\n    // Instruction to mint tokens to associated token account\n    const associatedTokenAddress = await getTokenAccountAddress(destination, mintAddress, true);\n\n    const mintToInstruction = getMintToInstruction({\n      mint: mintAddress,\n      token: associatedTokenAddress,\n      mintAuthority: mintAuthority.address,\n      amount: amount,\n    });\n\n    const transactionSignature = await sendTransactionFromInstructions({\n      feePayer: mintAuthority,\n      instructions: [createAtaInstruction, mintToInstruction],\n    });\n\n    return transactionSignature;\n  };\n  return mintTokens;\n};\n\nexport const getMintFactory = (rpc: ReturnType<typeof createSolanaRpcFromTransport>) => {\n  const getMint = async (mintAddress: Address, commitment: Commitment = \"confirmed\") => {\n    const mint = await fetchMint(rpc, mintAddress, { commitment });\n    return mint;\n  };\n\n  return getMint;\n};\n\nexport const getTokenAccountBalanceFactory = (rpc: ReturnType<typeof createSolanaRpcFromTransport>) => {\n  const getTokenAccountBalance = async (options: {\n    wallet?: Address;\n    mint?: Address;\n    tokenAccount?: Address;\n    useTokenExtensions?: boolean;\n  }) => {\n    const { wallet, mint, tokenAccount, useTokenExtensions } = options;\n    if (!options.tokenAccount) {\n      if (!wallet || !mint) {\n        throw new Error(\"wallet and mint are required when tokenAccount is not provided\");\n      }\n      options.tokenAccount = await getTokenAccountAddress(wallet, mint, useTokenExtensions);\n    }\n    const result = await rpc.getTokenAccountBalance(options.tokenAccount).send();\n\n    const { amount, decimals, uiAmount, uiAmountString } = result.value;\n\n    return {\n      amount: BigInt(amount),\n      decimals,\n      uiAmount,\n      uiAmountString,\n    };\n  };\n  return getTokenAccountBalance;\n};\n\nexport const checkTokenAccountIsClosedFactory = (\n  getTokenAccountBalance: ReturnType<typeof getTokenAccountBalanceFactory>,\n) => {\n  const checkTokenAccountIsClosed = async (options: {\n    wallet?: Address;\n    mint?: Address;\n    tokenAccount?: Address;\n    useTokenExtensions?: boolean;\n  }) => {\n    try {\n      await getTokenAccountBalance(options);\n      return false;\n    } catch (thrownObject) {\n      const error = thrownObject as Error;\n      if (error.message.includes(\"Invalid param: could not find account\")) {\n        return true;\n      }\n      throw error;\n    }\n  };\n  return checkTokenAccountIsClosed;\n};\n","import { KNOWN_CLUSTER_NAMES, CLUSTERS } from \"./clusters\";\nimport { checkIsValidURL, encodeURL } from \"./url\";\n\nexport const getExplorerLinkFactory = (clusterNameOrURL: string) => {\n  /**\n   * Gets a link to view an address, transaction, or block on Solana Explorer.\n   * The link will automatically use the current RPC configuration.\n   * @param {(\"transaction\" | \"tx\" | \"address\" | \"block\")} linkType - Type of entity to link to\n   * @param {string} id - The address, signature, or block to link to\n   * @returns {string} The complete Solana Explorer URL\n   */\n  const getExplorerLink = (linkType: \"transaction\" | \"tx\" | \"address\" | \"block\", id: string): string => {\n    const searchParams: Record<string, string> = {};\n    if (KNOWN_CLUSTER_NAMES.includes(clusterNameOrURL)) {\n      const clusterDetails = CLUSTERS[clusterNameOrURL];\n      // If they're using Solana Labs mainnet-beta, we don't need to include the cluster name in the Solana Explorer URL\n      // because it's the default\n      if (!clusterDetails.features.isExplorerDefault) {\n        if (clusterDetails.features.isNameKnownToSolanaExplorer) {\n          searchParams[\"cluster\"] = clusterNameOrURL;\n        } else {\n          searchParams[\"cluster\"] = \"custom\";\n        }\n        // We don't have to set searchParams[\"customUrl\"] for localnet - Explorer will connect to localnet by default\n        if (clusterNameOrURL !== \"localnet\") {\n          if (clusterDetails.requiredParam) {\n            const requiredParamEnvironmentVariable = clusterDetails.requiredParamEnvironmentVariable;\n            if (!requiredParamEnvironmentVariable) {\n              throw new Error(`Required param environment variable is not set for cluster ${clusterNameOrURL}`);\n            }\n            if (!process.env[requiredParamEnvironmentVariable]) {\n              throw new Error(`Environment variable '${requiredParamEnvironmentVariable}' is not set.`);\n            }\n            const apiKey = process.env[requiredParamEnvironmentVariable];\n\n            const params = new URLSearchParams({\n              [clusterDetails.requiredParam]: apiKey,\n            });\n            const urlWithParams = `${clusterDetails.httpURL}?${params.toString()}`;\n            searchParams[\"customUrl\"] = urlWithParams;\n          } else {\n            if (!clusterDetails.features.isNameKnownToSolanaExplorer) {\n              searchParams[\"customUrl\"] = clusterDetails.httpURL;\n            }\n          }\n        }\n      }\n    } else {\n      if (checkIsValidURL(clusterNameOrURL)) {\n        searchParams[\"cluster\"] = \"custom\";\n        searchParams[\"customUrl\"] = clusterNameOrURL;\n      } else {\n        throw new Error(`Unsupported cluster name: ${clusterNameOrURL}`);\n      }\n    }\n\n    let baseUrl: string = \"\";\n    if (linkType === \"address\") {\n      baseUrl = `https://explorer.solana.com/address/${id}`;\n    }\n    if (linkType === \"transaction\" || linkType === \"tx\") {\n      baseUrl = `https://explorer.solana.com/tx/${id}`;\n    }\n    if (linkType === \"block\") {\n      baseUrl = `https://explorer.solana.com/block/${id}`;\n    }\n    return encodeURL(baseUrl, searchParams);\n  };\n\n  return getExplorerLink;\n};\n","import {\n  Address,\n  createSolanaRpcSubscriptions,\n  Lamports,\n  Commitment,\n  createSolanaRpcFromTransport,\n  airdropFactory,\n} from \"@solana/kit\";\n\nexport const getLamportBalanceFactory = (rpc: ReturnType<typeof createSolanaRpcFromTransport>) => {\n  const getLamportBalance = async (address: string, commitment: Commitment = \"finalized\"): Promise<Lamports> => {\n    const getLamportBalanceResponse = await rpc.getBalance(address, { commitment }).send();\n    return getLamportBalanceResponse.value;\n  };\n  return getLamportBalance;\n};\n\nexport const airdropIfRequiredFactory = (\n  rpc: ReturnType<typeof createSolanaRpcFromTransport>,\n  rpcSubscriptions: ReturnType<typeof createSolanaRpcSubscriptions>,\n) => {\n  const getLamportBalance = getLamportBalanceFactory(rpc);\n  // Plain 'airdrop' is not exported as we don't want to encourage people to\n  // request airdrops when they don't need them, ie - don't bother\n  // the faucet unless you really need to!\n  //\n  // Note rpc.requestAirdrop is broken, the commitment parameter doesn't do anything\n  // despite the docs repeatedly referring to rpc.requestAirdrop\n  // See https://github.com/solana-labs/solana-web3.js/issues/3683\n  //\n  // @ts-expect-error TODO need to work out devnet/mainnet typing issue re: airdrops\n  const airdrop = airdropFactory({ rpc, rpcSubscriptions });\n\n  const airdropIfRequired = async (\n    address: Address,\n    airdropAmount: Lamports,\n    minimumBalance: Lamports,\n    // We're being conservative here, using the 'finalized' commitment\n    // level because we want to ensure the SOL is always available\n    // when the function return and users try and spend it.\n    commitment: Commitment = \"finalized\",\n  ): Promise<string | null> => {\n    if (airdropAmount < 0n) {\n      throw new Error(`Airdrop amount must be a positive number, not ${airdropAmount}`);\n    }\n    if (minimumBalance === 0n) {\n      const signature = await airdrop({\n        commitment,\n        recipientAddress: address,\n        lamports: airdropAmount,\n      });\n      return signature;\n    }\n    const balance = await getLamportBalance(address, commitment);\n\n    if (balance >= minimumBalance) {\n      return null;\n    }\n    const signature = await airdrop({\n      commitment,\n      recipientAddress: address,\n      lamports: airdropAmount,\n    });\n\n    return signature;\n  };\n  return airdropIfRequired;\n};\n","import { Address, getAddressEncoder, getProgramDerivedAddress } from \"@solana/kit\";\n\nconst addressEncoder = getAddressEncoder();\n\n// The web3.js c2 equivalent of\n//    bigNumber.toArrayLike(Buffer, \"le\", 8),\n// from web3.js v1\nconst bigintToSeed = (num: bigint, byteLength: number): Buffer => {\n  const arr = new Uint8Array(byteLength);\n  for (let i = 0; i < byteLength && num > 0n; i++) {\n    arr[i] = Number(num & 0xffn); // Get least significant byte\n    num >>= 8n; // Shift right by 8 bits\n  }\n  return Buffer.from(arr); // Convert to Buffer for Solana\n};\n\n/**\n * Calculates a Program Derived Address (PDA) and its bump seed from a program address and seeds.\n * Automatically handles encoding of different seed types (strings, addresses, and bigints).\n * @param {Address} programAddress - The program address to derive the PDA from\n * @param {Array<String | Address | BigInt>} seeds - Array of seeds to derive the PDA\n * @returns {Promise<{pda: Address, bump: number}>} The derived PDA and its bump seed\n */\nexport const getPDAAndBump = async (programAddress: Address, seeds: Array<String | Address | BigInt>) => {\n  const bufferSeeds = seeds.map((seed) => {\n    if (typeof seed === \"bigint\") {\n      return bigintToSeed(seed, 8);\n    }\n\n    // Try to encode as Address, if it fails treat as string\n    // (since Address is an extension of String at runtime)\n    try {\n      const encoded = addressEncoder.encode(seed as Address);\n      return encoded;\n    } catch {\n      return Buffer.from(seed as string);\n    }\n  });\n  const [pda, bump] = await getProgramDerivedAddress({\n    seeds: bufferSeeds,\n    programAddress,\n  });\n  return { pda, bump };\n};\n","import {\n  type Address,\n  decodeAccount,\n  MaybeEncodedAccount,\n  parseBase64RpcAccount,\n  type Decoder,\n  createSolanaRpcFromTransport,\n} from \"@solana/kit\";\nimport bs58 from \"bs58\";\n\n// OK brother hear me out\n// 'FactoryFactory' seems weird but:\n// - The first factory returns a second factory, with the RPC connection baked in\n// - That second factory people can use to create a 'getOffers' or 'getAuctions' or 'getUsers'\nexport const getAccountsFactoryFactory = (rpc: ReturnType<typeof createSolanaRpcFromTransport>) => {\n  /**\n   * Creates a function that gets all program accounts of a particular type\n   * @param {Address} programAddress - The program address to query accounts from\n   * @param {Uint8Array} discriminator - The discriminator to filter accounts by\n   * @param {Decoder<T>} decoder - The decoder to use for parsing account data\n   * @returns {() => Promise<Array<T>>} A function that returns an array of decoded accounts\n   *\n   * @example\n   * ```typescript\n   * export const getOffers = getAccountsFactory(\n   *   programClient.ESCROW_PROGRAM_ADDRESS,\n   *   OFFER_DISCRIMINATOR,\n   *   getOfferDecoder(),\n   * );\n   * ```\n   */\n  const getAccountsFactory = <T extends object>(\n    programAddress: Address,\n    discriminator: Uint8Array,\n    decoder: Decoder<T>,\n  ) => {\n    return async () => {\n      // See https://solana.com/docs/rpc/http/getprogramaccounts\n      const getProgramAccountsResults = await rpc\n        .getProgramAccounts(programAddress, {\n          encoding: \"jsonParsed\",\n          filters: [\n            {\n              memcmp: {\n                offset: 0,\n                bytes: bs58.encode(Buffer.from(discriminator)),\n              },\n            },\n          ],\n        })\n        .send();\n\n      // getProgramAccounts uses one format\n      // decodeAccount uses another\n      const encodedAccounts: Array<MaybeEncodedAccount> = getProgramAccountsResults.map((result: any) => {\n        const account = parseBase64RpcAccount(result.pubkey, result.account);\n        return {\n          ...account,\n          data: Buffer.from(account.data),\n          exists: true,\n        };\n      });\n\n      const decodedAccounts = encodedAccounts.map((maybeAccount) => {\n        return decodeAccount(maybeAccount, decoder);\n      });\n      return decodedAccounts;\n    };\n  };\n  return getAccountsFactory;\n};\n"],"mappings":"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","names":["createSolanaRpcFromTransport","createSolanaRpcSubscriptions","sendAndConfirmTransactionFactory","getSetComputeUnitPriceInstruction","getSetComputeUnitPriceInstruction","generateKeyPairSigner","generateKeyPairSigner","signature","bs58","createSolanaRpcFromTransport","createSolanaRpcSubscriptions","sendAndConfirmTransactionFactory"]}